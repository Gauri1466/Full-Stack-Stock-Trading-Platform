<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Tests</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <!-- Google AI SDK -->
    <script src="https://generativelanguage.googleapis.com/v1beta/models/gemini-pro"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            min-height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            color: #fff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-top: 30px;
            margin-bottom: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            position: relative;
        }

        .header h1 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .streak-counter {
            font-size: 1.2em;
            color: #ffd700;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .date-display {
            font-size: 1.1em;
            color: #a8a8a8;
            margin: 10px 0;
        }

        .question-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .question-section h2 {
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .question {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: transform 0.3s ease;
        }

        .question:hover {
            transform: translateY(-2px);
        }

        .question h3 {
            color: #fff;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .answer-input {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            margin-top: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            resize: vertical;
            font-size: 1em;
        }

        .answer-input:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .submit-btn {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            margin-top: 10px;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .submit-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .submit-btn.submitted {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
        }

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #4a90e2;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2em;
            color: #fff;
            text-align: center;
        }

        .leaderboard-section {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .leaderboard-table th,
        .leaderboard-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-table th {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .leaderboard-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .answer-feedback {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        .answer-feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .answer-feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .nav-button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .feedback-header {
            font-weight: bold;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }

        .feedback-header.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback-header.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .feedback-content {
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-top: 5px;
            white-space: pre-wrap;
        }

        .error-feedback {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            padding: 10px;
            border-radius: 4px;
        }

        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            color: #333;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .completion-content h2 {
            color: #2ecc71;
            margin-bottom: 15px;
        }

        .error-details {
            background: rgba(231, 76, 60, 0.1);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .error-details p {
            margin: 5px 0;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-code"></i> Daily Coding Challenge</h1>
            <p>Test your skills and climb the leaderboard!</p>
            <div class="streak-counter">
                <i class="fas fa-fire"></i>
                <span id="streak-counter">Current Streak: 0 days</span>
            </div>
            <div class="date-display" id="date-display"></div>
            <div class="progress-bar">
                <div class="progress" id="progress" style="width: 0%"></div>
            </div>
        </div>

        <div id="loading" class="loading-container">
            <div class="loading-spinner"></div>
            <div class="loading-text">Generating your daily challenges...</div>
            <div id="loading-status" style="color: #a8a8a8; margin-top: 10px; font-size: 0.9em;">Initializing...</div>
        </div>

        <div id="error" class="error-message" style="display: none;"></div>

        <div id="questions-container" style="display: none;">
            <!-- Theory Questions -->
            <div class="question-section">
                <h2><i class="fas fa-book"></i> Theory Questions</h2>
                <div class="question" id="theory-q1">
                    <h3><i class="fas fa-question-circle"></i> Question 1</h3>
                    <p id="theory-q1-text"></p>
                    <textarea class="answer-input" placeholder="Your answer here..."></textarea>
                    <button class="submit-btn" onclick="submitAnswer('theory', 1)">Submit</button>
                    <div class="answer-feedback" id="theory-q1-feedback"></div>
                </div>
                <div class="question" id="theory-q2">
                    <h3><i class="fas fa-question-circle"></i> Question 2</h3>
                    <p id="theory-q2-text"></p>
                    <textarea class="answer-input" placeholder="Your answer here..."></textarea>
                    <button class="submit-btn" onclick="submitAnswer('theory', 2)">Submit</button>
                    <div class="answer-feedback" id="theory-q2-feedback"></div>
                </div>
            </div>

            <!-- Coding Questions -->
            <div class="question-section">
                <h2><i class="fas fa-laptop-code"></i> Coding Questions</h2>
                <div class="question" id="coding-q1">
                    <h3><i class="fas fa-code"></i> Question 1</h3>
                    <p id="coding-q1-text"></p>
                    <textarea class="answer-input" placeholder="Your code here..."></textarea>
                    <button class="submit-btn" onclick="submitAnswer('coding', 1)">Submit</button>
                    <div class="answer-feedback" id="coding-q1-feedback"></div>
                </div>
                <div class="question" id="coding-q2">
                    <h3><i class="fas fa-code"></i> Question 2</h3>
                    <p id="coding-q2-text"></p>
                    <textarea class="answer-input" placeholder="Your code here..."></textarea>
                    <button class="submit-btn" onclick="submitAnswer('coding', 2)">Submit</button>
                    <div class="answer-feedback" id="coding-q2-feedback"></div>
                </div>
            </div>

            <!-- Aptitude Question -->
            <div class="question-section">
                <h2><i class="fas fa-brain"></i> Aptitude Question</h2>
                <div class="question" id="aptitude-q1">
                    <h3><i class="fas fa-calculator"></i> Question 1</h3>
                    <p id="aptitude-q1-text"></p>
                    <textarea class="answer-input" placeholder="Your answer here..."></textarea>
                    <button class="submit-btn" onclick="submitAnswer('aptitude', 1)">Submit</button>
                    <div class="answer-feedback" id="aptitude-q1-feedback"></div>
                </div>
            </div>

            <!-- Leaderboard Section -->
            <div class="leaderboard-section">
                <h2><i class="fas fa-trophy"></i> Leaderboard</h2>
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>User</th>
                            <th>Streak</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body">
                        <!-- Leaderboard entries will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDhGLjdmSOP0dDMSfDf9H_A_lsIaM4krI4",
            authDomain: "takeiteasy-a3b0e.firebaseapp.com",
            projectId: "takeiteasy-a3b0e",
            storageBucket: "takeiteasy-a3b0e.firebasestorage.app",
            messagingSenderId: "89777118804",
            appId: "1:89777118804:web:41356a3f288f0e983557c1",
            measurementId: "G-1YHN5E8H2L"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // Initialize Hugging Face API
        const HUGGING_FACE_API_KEY = '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';
        
        async function generateContent(prompt) {
            try {
                console.log('Sending request to Hugging Face API...');
                const response = await fetch(
                    'https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2',
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${HUGGING_FACE_API_KEY}`
                        },
                        body: JSON.stringify({
                            inputs: prompt,
                            parameters: {
                                max_new_tokens: 500,
                                temperature: 0.7,
                                top_p: 0.95,
                                return_full_text: false
                            }
                        })
                    }
                );

                console.log('Response status:', response.status);
                const responseData = await response.json();
                console.log('API Response:', responseData);

                if (!response.ok) {
                    throw new Error(`API Error: ${responseData.error || response.statusText}`);
                }

                if (!responseData[0]?.generated_text) {
                    throw new Error('Invalid response format from API');
                }

                return responseData[0].generated_text;
            } catch (error) {
                console.error('Error in generateContent:', error);
                throw error;
            }
        }

        async function retryWithDelay(fn, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    console.log(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        let questions = {
            theory: [],
            coding: [],
            aptitude: []
        };

        // Modified generateQuestions function
        async function generateQuestions() {
            try {
                const userId = auth.currentUser?.uid;
                if (!userId) {
                    throw new Error('User not authenticated');
                }

                // First check if questions exist for today
                const todaysQuestions = await getTodaysQuestions(userId);
                if (todaysQuestions.exists) {
                    questions = todaysQuestions.questions;
                    return true;
                }

                updateLoadingStatus('Generating new questions for today...');

                // Generate theory questions
                updateLoadingStatus('Generating theory questions...');
                const theoryQuestions = await retryWithDelay(async () => {
                    const prompt = `[INST] Create 2 unique and challenging programming theory questions:
                        1. A basic question about fundamental programming concepts
                        2. An advanced question about software development practices
                        
                        Format: Return ONLY the questions, one per line, no numbering or extra text.
                        Make questions clear, specific, and different from common examples.
                        Focus on practical understanding rather than memorization. [/INST]`;
                    
                    const response = await generateContent(prompt);
                    const questions = response.split('\n').filter(q => q.trim());
                    if (questions.length < 2) throw new Error('Insufficient theory questions generated');
                    return questions.slice(0, 2);
                });
                questions.theory = theoryQuestions;

                // Generate coding questions
                updateLoadingStatus('Generating coding questions...');
                const codingQuestions = await retryWithDelay(async () => {
                    const prompt = `[INST] Create 2 unique and challenging coding questions:
                        1. A practical programming task (like string manipulation or array operations)
                        2. An advanced algorithm or data structure problem
                        
                        Format: Return ONLY the questions, one per line, no numbering or extra text.
                        Make questions clear, specific, and different from common examples.
                        Include specific requirements and constraints. [/INST]`;
                    
                    const response = await generateContent(prompt);
                    const questions = response.split('\n').filter(q => q.trim());
                    if (questions.length < 2) throw new Error('Insufficient coding questions generated');
                    return questions.slice(0, 2);
                });
                questions.coding = codingQuestions;

                // Generate aptitude question
                updateLoadingStatus('Generating aptitude question...');
                const aptitudeQuestion = await retryWithDelay(async () => {
                    const prompt = `[INST] Create 1 unique and challenging mathematical or logical reasoning question.
                        Make it challenging but solvable.
                        Format: Return ONLY the question, no extra text.
                        The question should test analytical thinking and problem-solving skills. [/INST]`;
                    
                    const response = await generateContent(prompt);
                    const question = response.trim();
                    if (!question) throw new Error('No aptitude question generated');
                    return [question];
                });
                questions.aptitude = aptitudeQuestion;

                // Store questions in Firestore
                await storeTodaysQuestions(questions);
                console.log('Successfully generated and stored questions:', questions);

                return true;
            } catch (error) {
                console.error('Error in generateQuestions:', error);
                
                // Show error to user
                const errorDiv = document.getElementById('error');
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div class="error-details">
                        <p>Error generating questions: ${error.message}</p>
                        <p>Please try refreshing the page or try again later.</p>
                    </div>
                `;
                
                return false;
            }
        }

        // Function to get random questions
        function getRandomQuestions(type, count) {
            const allQuestions = [...questionDatabase[type]];
            const selectedQuestions = [];
            
            for (let i = 0; i < count; i++) {
                if (allQuestions.length === 0) break;
                const randomIndex = Math.floor(Math.random() * allQuestions.length);
                selectedQuestions.push(allQuestions[randomIndex]);
                allQuestions.splice(randomIndex, 1);
            }
            
            return selectedQuestions;
        }

        // Function to check if questions are already generated for today
        async function getTodaysQuestions(userId) {
            const today = new Date().toISOString().split('T')[0];
            try {
                // Check if questions exist for today in Firestore
                const questionsSnapshot = await db.collection('dailyQuestions')
                    .where('date', '==', today)
                    .limit(1)
                    .get();

                if (!questionsSnapshot.empty) {
                    // Questions already exist for today, use them
                    const questionDoc = questionsSnapshot.docs[0];
                    return {
                        exists: true,
                        questions: questionDoc.data().questions
                    };
                }

                return { exists: false };
            } catch (error) {
                console.error('Error checking today\'s questions:', error);
                return { exists: false };
            }
        }

        // Function to store today's questions
        async function storeTodaysQuestions(questions) {
            const today = new Date().toISOString().split('T')[0];
            try {
                await db.collection('dailyQuestions').add({
                    date: today,
                    questions: questions,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                return true;
            } catch (error) {
                console.error('Error storing questions:', error);
                return false;
            }
        }

        // Add cleanup function for old questions
        async function cleanupOldQuestions() {
            try {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                const thirtyDaysAgoStr = thirtyDaysAgo.toISOString().split('T')[0];

                const oldQuestions = await db.collection('dailyQuestions')
                    .where('date', '<', thirtyDaysAgoStr)
                    .get();

                const batch = db.batch();
                oldQuestions.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
            } catch (error) {
                console.error('Error cleaning up old questions:', error);
            }
        }

        // Run cleanup once a day
        const now = new Date();
        const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
        const timeUntilTomorrow = tomorrow - now;
        setTimeout(cleanupOldQuestions, timeUntilTomorrow);

        function updateLoadingStatus(status) {
            const statusElement = document.getElementById('loading-status');
            if (statusElement) {
                statusElement.textContent = status;
            }
        }

        // Modified checkAnswer function
        async function checkAnswer(type, number, answer) {
            try {
                updateLoadingStatus('Checking your answer...');
                const question = questions[type][number-1];
                let prompt = '';

                switch(type) {
                    case 'theory':
                        prompt = `[INST] As an expert programming instructor, evaluate this theory answer.
Question: "${question}"
Student's Answer: "${answer}"
Evaluate the answer and respond in this exact format:
CORRECT/INCORRECT
Score (0-10): [score]
Feedback: [detailed explanation]
Key Concepts: [list key programming concepts covered/missing] [/INST]`;
                        break;
                    
                    case 'coding':
                        prompt = `[INST] As an expert programming instructor, evaluate this code solution.
Question: "${question}"
Student's Code: "${answer}"
Evaluate the code and respond in this exact format:
CORRECT/INCORRECT
Score (0-10): [score]
Feedback: [detailed code review with suggestions]
Key Concepts: [list key programming concepts used/missing]
Improvements: [suggest specific improvements] [/INST]`;
                        break;
                    
                    case 'aptitude':
                        prompt = `[INST] As a math and logic instructor, evaluate this aptitude answer.
Question: "${question}"
Student's Answer: "${answer}"
Evaluate the answer and respond in this exact format:
CORRECT/INCORRECT
Score (0-10): [score]
Feedback: [detailed explanation with correct approach]
Steps: [list the correct steps to solve] [/INST]`;
                        break;
                }

                const response = await generateContent(prompt);
                const lines = response.split('\n');
                
                // Parse the response
                const isCorrect = lines[0].trim().toUpperCase() === 'CORRECT';
                const score = parseInt(lines[1].match(/Score \(0-10\): (\d+)/)?.[1] || '0');
                const feedback = lines.slice(2).join('\n').replace('Feedback:', '').trim();

                return {
                    isCorrect,
                    score,
                    feedback,
                    status: 'success'
                };
            } catch (error) {
                console.error('Error checking answer:', error);
                return {
                    isCorrect: false,
                    score: 0,
                    feedback: 'Error checking answer. Please try again.',
                    status: 'error'
                };
            }
        }

        // Wait for authentication state to be ready
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log('User is authenticated:', user.uid);
                await fetchQuestions();
            } else {
                console.log('No user authenticated, redirecting to login');
                window.location.href = 'login.html';
            }
        });

        let submittedAnswers = {
            theory: [false, false],
            coding: [false, false],
            aptitude: [false]
        };

        async function fetchQuestions() {
            try {
                updateLoadingStatus('Checking authentication...');
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('date-display').textContent = `Today's Date: ${today}`;

                const user = auth.currentUser;
                if (!user) {
                    updateLoadingStatus('Not authenticated, redirecting to login...');
                    window.location.href = 'login.html';
                    return;
                }

                updateLoadingStatus('Checking previous submissions...');
                try {
                    const todayAnswers = await db.collection('answers')
                        .where('userId', '==', user.uid)
                        .where('date', '==', today)
                        .get();

                    if (!todayAnswers.empty) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').textContent = 'You have already completed today\'s questions. Come back tomorrow!';
                        return;
                    }
                } catch (firestoreError) {
                    console.error('Firestore error:', firestoreError);
                    throw firestoreError;
                }

                updateLoadingStatus('Fetching your current streak...');
                try {
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    const streak = userDoc.data()?.streak || 0;
                    document.getElementById('streak-counter').textContent = `Current Streak: ${streak} days`;
                } catch (streakError) {
                    console.error('Error fetching streak:', streakError);
                }

                updateLoadingStatus('Generating questions using AI...');
                const success = await generateQuestions();
                
                if (!success) {
                    throw new Error('Failed to generate questions');
                }

                updateLoadingStatus('Preparing your challenge interface...');
                // Update theory questions
                document.getElementById('theory-q1-text').textContent = questions.theory[0];
                document.getElementById('theory-q2-text').textContent = questions.theory[1];
                
                // Update coding questions
                document.getElementById('coding-q1-text').textContent = questions.coding[0];
                document.getElementById('coding-q2-text').textContent = questions.coding[1];
                
                // Update aptitude question
                document.getElementById('aptitude-q1-text').textContent = questions.aptitude[0];

                // Show questions and hide loading
                document.getElementById('loading').style.display = 'none';
                document.getElementById('questions-container').style.display = 'block';
                
            } catch (error) {
                console.error('Error in fetchQuestions:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error: ${error.message}. Please try refreshing the page.`;
            }
        }

        async function submitAnswer(type, number) {
            const userId = auth.currentUser?.uid;
            if (!userId) {
                alert('Please log in to submit answers');
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const answerInput = document.querySelector(`#${type}-q${number} .answer-input`);
            const submitButton = answerInput.parentElement.querySelector('.submit-btn');
            const feedbackDiv = document.getElementById(`${type}-q${number}-feedback`);
            const answer = answerInput.value.trim();

            if (!answer) {
                alert('Please enter your answer');
                return;
            }

            try {
                // Disable submit button and show loading
                submitButton.disabled = true;
                submitButton.textContent = 'Checking...';
                
                // Check answer
                const result = await checkAnswer(type, number, answer);
                
                // Store answer and result in Firestore
                await db.collection('answers').add({
                    userId,
                    type,
                    questionNumber: number,
                    question: questions[type][number-1],
                    answer,
                    isCorrect: result.isCorrect,
                    score: result.score,
                    feedback: result.feedback,
                    date: today,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Update user's score in Firestore
                const userRef = db.collection('users').doc(userId);
                await db.runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userRef);
                    const currentScore = userDoc.data()?.score || 0;
                    const newScore = currentScore + result.score;
                    transaction.update(userRef, { score: newScore });
                });

                // Mark as submitted
                submittedAnswers[type][number - 1] = true;
                submitButton.classList.add('submitted');
                submitButton.disabled = true;
                submitButton.textContent = result.isCorrect ? '✓ Correct' : '× Incorrect';
                answerInput.disabled = true;

                // Show feedback with styling
                feedbackDiv.innerHTML = `
                    <div class="feedback-header ${result.isCorrect ? 'correct' : 'incorrect'}">
                        ${result.isCorrect ? '✓ Correct' : '× Incorrect'} (Score: ${result.score}/10)
                    </div>
                    <div class="feedback-content">
                        ${result.feedback}
                    </div>
                `;
                feedbackDiv.style.display = 'block';
                feedbackDiv.className = `answer-feedback ${result.isCorrect ? 'correct' : 'incorrect'}`;

                // Update progress
                const progress = document.getElementById('progress');
                const currentWidth = parseInt(progress.style.width) || 0;
                progress.style.width = `${currentWidth + 20}%`;

                // Update leaderboard
                await updateLeaderboard();

                // Check if all answers are submitted
                const allSubmitted = Object.values(submittedAnswers).every(
                    answers => answers.every(submitted => submitted)
                );

                if (allSubmitted) {
                    showCompletionMessage();
                }

            } catch (error) {
                console.error('Error submitting answer:', error);
                submitButton.disabled = false;
                submitButton.textContent = 'Submit';
                feedbackDiv.innerHTML = `
                    <div class="error-feedback">
                        Error submitting answer. Please try again.
                    </div>
                `;
                feedbackDiv.style.display = 'block';
            }
        }

        function showCompletionMessage() {
            const completionMessage = document.createElement('div');
            completionMessage.className = 'completion-message';
            completionMessage.innerHTML = `
                <div class="completion-content">
                    <h2>🎉 Congratulations!</h2>
                    <p>You've completed today's coding challenge.</p>
                    <p>Come back tomorrow for new questions!</p>
                </div>
            `;
            document.querySelector('.container').appendChild(completionMessage);
        }

        async function updateLeaderboard() {
            try {
                const leaderboardSnapshot = await db.collection('users')
                    .orderBy('streak', 'desc')
                    .orderBy('score', 'desc')
                    .limit(10)
                    .get();

                const leaderboardBody = document.getElementById('leaderboard-body');
                leaderboardBody.innerHTML = '';

                let rank = 1;
                leaderboardSnapshot.forEach(doc => {
                    const userData = doc.data();
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${rank}</td>
                        <td>${userData.email || 'Anonymous'}</td>
                        <td>${userData.streak || 0} days</td>
                        <td>${userData.score || 0}</td>
                    `;
                    leaderboardBody.appendChild(row);
                    rank++;
                });
            } catch (error) {
                console.error('Error updating leaderboard:', error);
            }
        }

        async function submitAllAnswers() {
            const userId = auth.currentUser?.uid;
            if (!userId) {
                alert('Please log in to submit answers');
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const finalSubmitBtn = document.querySelector('.final-submit-btn');
            finalSubmitBtn.disabled = true;

            try {
                const userRef = db.collection('users').doc(userId);
                const userDoc = await userRef.get();
                const currentStreak = userDoc.data()?.streak || 0;
                const lastAnswerDate = userDoc.data()?.lastAnswerDate;
                
                // Check if last answer was yesterday
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];
                
                if (lastAnswerDate === yesterdayStr) {
                    await userRef.update({
                        streak: currentStreak + 1,
                        lastAnswerDate: today
                    });
                    document.getElementById('streak-counter').textContent = `Current Streak: ${currentStreak + 1} days`;
                } else if (!lastAnswerDate || lastAnswerDate !== today) {
                    await userRef.set({
                        streak: 1,
                        lastAnswerDate: today
                    }, { merge: true });
                    document.getElementById('streak-counter').textContent = 'Current Streak: 1 day';
                }

                finalSubmitBtn.textContent = 'All Answers Submitted!';
                finalSubmitBtn.style.backgroundColor = '#2ecc71';
                alert('All your answers have been submitted successfully!');
            } catch (error) {
                console.error('Error submitting all answers:', error);
                alert('Error submitting answers. Please try again.');
                finalSubmitBtn.disabled = false;
            }
        }
    </script>
</body>
</html>